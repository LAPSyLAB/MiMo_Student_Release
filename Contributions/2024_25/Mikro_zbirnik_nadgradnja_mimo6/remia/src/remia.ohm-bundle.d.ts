// AUTOGENERATED FILE
// This file was generated from remia.ohm by `ohm generateBundles`.

import {
  BaseActionDict,
  Grammar,
  IterationNode,
  Node,
  NonterminalNode,
  Semantics,
  TerminalNode
} from 'ohm-js';

export interface AssemblerActionDict<T> extends BaseActionDict<T> {
  Program?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
  Expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ConstDef?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Directive?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  AtDirective?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  VarDirective?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  IncludeDirective?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  StringDirective?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  Label?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  label?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode) => T;
  Instruction_rrr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode, arg5: NonterminalNode) => T;
  Instruction_rri?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode, arg5: NonterminalNode) => T;
  Instruction_rX?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Instruction_rr?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Instruction_ri?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Instruction_rb?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode) => T;
  Instruction_r?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Instruction_i?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Instruction_b?: (this: NonterminalNode, arg0: NonterminalNode, arg1: NonterminalNode) => T;
  Instruction_n?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Instruction?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  ArglessMnemonic?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FullIndex_R?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  FullIndex_I?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  FullIndex_RR?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  FullIndex_RI?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode, arg3: NonterminalNode, arg4: TerminalNode) => T;
  FullIndex?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  BRIndex?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: TerminalNode) => T;
  Immed_named?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Immed_literal?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  Immed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  namedImmed?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  literalImmed?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  constName?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  hexNumber?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  decimalNumber?: (this: NonterminalNode, arg0: IterationNode) => T;
  ws?: (this: NonterminalNode, arg0: IterationNode) => T;
  register_numbered?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  register_named?: (this: NonterminalNode, arg0: TerminalNode) => T;
  register?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  rdigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
  mnemonic?: (this: NonterminalNode, arg0: TerminalNode) => T;
  arglessMnemonic?: (this: NonterminalNode, arg0: TerminalNode) => T;
  name?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
  stringExpr?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
  doubleStringCharacter_nonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  doubleStringCharacter_escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  doubleStringCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  escapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  characterEscapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  nonEscapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  hexEscapeSequence?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
  lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
  sourceCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  lineContinuation?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
  escapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  singleEscapeCharacter?: (this: NonterminalNode, arg0: TerminalNode) => T;
  space?: (this: NonterminalNode, arg0: NonterminalNode) => T;
  comment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
  whitespace_verticalTab?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace_formFeed?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace_noBreakSpace?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace_byteOrderMark?: (this: NonterminalNode, arg0: TerminalNode) => T;
  whitespace?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
  lineTerminatorSequence?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface AssemblerSemantics extends Semantics {
  addOperation<T>(name: string, actionDict: AssemblerActionDict<T>): this;
  extendOperation<T>(name: string, actionDict: AssemblerActionDict<T>): this;
  addAttribute<T>(name: string, actionDict: AssemblerActionDict<T>): this;
  extendAttribute<T>(name: string, actionDict: AssemblerActionDict<T>): this;
}

export interface AssemblerGrammar extends Grammar {
  createSemantics(): AssemblerSemantics;
  extendSemantics(superSemantics: AssemblerSemantics): AssemblerSemantics;
}

declare const grammar: AssemblerGrammar;
export default grammar;

